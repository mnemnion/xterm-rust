var searchIndex = {};
searchIndex['mod'] = {"items":[[0,"","mod","#Xterm Library for Rust"],[0,"xvec","",""],[1,"XVec","mod::xvec","XVec: represents a composed string."],[11,"v","","",0],[2,"XString","","XString: these are the valid types of string for xterm markup."],[12,"Esc","","",1],[12,"Jump","","",1],[12,"Text","","",1],[3,"print_x","",""],[3,"make_jump","",""],[3,"line_split","","splits a line"],[3,"private_dancer","","none of your beeswax"],[10,"fmt","","",1],[10,"print","","",0],[10,"print_clean","","",0],[0,"color","mod",""],[2,"Colors","mod::color",""],[12,"Red","","",2],[12,"Blue","","",2],[12,"Green","","",2],[12,"Yellow","","",2],[12,"Magenta","","",2],[12,"Cyan","","",2],[12,"White","","",2],[12,"Default","","",2],[3,"color_fg","",""],[3,"color_bg","",""],[0,"nav","mod",""],[1,"Point","mod::nav","represents a point in terminal space."],[11,"row","","",3],[11,"col","","",3],[1,"Frame","","represents a rectangular region of terminal space."],[11,"tl","","",4],[11,"br","","",4],[3,"save_cursor","","saves cursor at terminal level."],[3,"restore_cursor","","restores cursor at terminal level"],[3,"new_frame","",""],[3,"draw_frame","","currently this just draws a box around a frame."],[3,"jump_string","","returns a string that will generate a jump to pt."],[3,"jump","","executes a jump."],[3,"page","",""],[3,"cleanup","",""],[10,"eq","","",3],[10,"ne","","",3],[10,"eq","","",4],[10,"ne","","",4],[10,"inside","","returns a Frame with dimensions one less than original.",4],[10,"move_to","","returns a Frame of the same width and height, translated to pt.\npt will be the top left, as is conventional.",4],[10,"on_top","","tests whether or not a point is on top of a frame.\nneeded, eventually, for intersection code.\nthere will be many of these functions. I wrote one for practice.",4]],"paths":[[1,"XVec"],[2,"XString"],[2,"Colors"],[1,"Point"],[1,"Frame"]]};
searchIndex['main'] = {"items":[[0,"","main","#Xterm Library for Rust"]],"paths":[]};

initSearch(searchIndex);
